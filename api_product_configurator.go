/*
Product Configurator Service

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: v1
Contact: info@gemini-commerce.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ProductConfiguratorApiService ProductConfiguratorApi service
type ProductConfiguratorApiService service

type ApiProductConfiguratorBulkCreateOptionsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	stepId string
	body *ProductconfiguratoroptionBulkCreateRequest
}

func (r ApiProductConfiguratorBulkCreateOptionsRequest) Body(body ProductconfiguratoroptionBulkCreateRequest) ApiProductConfiguratorBulkCreateOptionsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkCreateOptionsRequest) Execute() (*ProductconfiguratoroptionBulkCreateResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkCreateOptionsExecute(r)
}

/*
ProductConfiguratorBulkCreateOptions Method for ProductConfiguratorBulkCreateOptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param stepId
 @return ApiProductConfiguratorBulkCreateOptionsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkCreateOptions(ctx context.Context, tenantId string, stepId string) ApiProductConfiguratorBulkCreateOptionsRequest {
	return ApiProductConfiguratorBulkCreateOptionsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		stepId: stepId,
	}
}

// Execute executes the request
//  @return ProductconfiguratoroptionBulkCreateResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkCreateOptionsExecute(r ApiProductConfiguratorBulkCreateOptionsRequest) (*ProductconfiguratoroptionBulkCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratoroptionBulkCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkCreateOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{stepId}/option/create/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepId"+"}", url.PathEscape(parameterToString(r.stepId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorBulkCreatePropertiesRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratorpropertyBulkCreateRequest
}

func (r ApiProductConfiguratorBulkCreatePropertiesRequest) Body(body ProductconfiguratorpropertyBulkCreateRequest) ApiProductConfiguratorBulkCreatePropertiesRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkCreatePropertiesRequest) Execute() (*ProductconfiguratorpropertyBulkCreateResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkCreatePropertiesExecute(r)
}

/*
ProductConfiguratorBulkCreateProperties Method for ProductConfiguratorBulkCreateProperties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorBulkCreatePropertiesRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkCreateProperties(ctx context.Context, tenantId string) ApiProductConfiguratorBulkCreatePropertiesRequest {
	return ApiProductConfiguratorBulkCreatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorpropertyBulkCreateResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkCreatePropertiesExecute(r ApiProductConfiguratorBulkCreatePropertiesRequest) (*ProductconfiguratorpropertyBulkCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorpropertyBulkCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkCreateProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/property/create/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorBulkCreateStepsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	configuratorId string
	body *ProductconfiguratorstepBulkCreateRequest
}

func (r ApiProductConfiguratorBulkCreateStepsRequest) Body(body ProductconfiguratorstepBulkCreateRequest) ApiProductConfiguratorBulkCreateStepsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkCreateStepsRequest) Execute() (*ProductconfiguratorstepBulkCreateResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkCreateStepsExecute(r)
}

/*
ProductConfiguratorBulkCreateSteps Method for ProductConfiguratorBulkCreateSteps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param configuratorId
 @return ApiProductConfiguratorBulkCreateStepsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkCreateSteps(ctx context.Context, tenantId string, configuratorId string) ApiProductConfiguratorBulkCreateStepsRequest {
	return ApiProductConfiguratorBulkCreateStepsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		configuratorId: configuratorId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorstepBulkCreateResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkCreateStepsExecute(r ApiProductConfiguratorBulkCreateStepsRequest) (*ProductconfiguratorstepBulkCreateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorstepBulkCreateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkCreateSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/configurator/{configuratorId}/step/create/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuratorId"+"}", url.PathEscape(parameterToString(r.configuratorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorBulkDeleteOptionsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratoroptionBulkDeleteRequest
}

func (r ApiProductConfiguratorBulkDeleteOptionsRequest) Body(body ProductconfiguratoroptionBulkDeleteRequest) ApiProductConfiguratorBulkDeleteOptionsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkDeleteOptionsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkDeleteOptionsExecute(r)
}

/*
ProductConfiguratorBulkDeleteOptions Method for ProductConfiguratorBulkDeleteOptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorBulkDeleteOptionsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkDeleteOptions(ctx context.Context, tenantId string) ApiProductConfiguratorBulkDeleteOptionsRequest {
	return ApiProductConfiguratorBulkDeleteOptionsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkDeleteOptionsExecute(r ApiProductConfiguratorBulkDeleteOptionsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkDeleteOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/option/delete/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorBulkDeleteStepsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratorstepBulkDeleteRequest
}

func (r ApiProductConfiguratorBulkDeleteStepsRequest) Body(body ProductconfiguratorstepBulkDeleteRequest) ApiProductConfiguratorBulkDeleteStepsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkDeleteStepsRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkDeleteStepsExecute(r)
}

/*
ProductConfiguratorBulkDeleteSteps Method for ProductConfiguratorBulkDeleteSteps

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorBulkDeleteStepsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkDeleteSteps(ctx context.Context, tenantId string) ApiProductConfiguratorBulkDeleteStepsRequest {
	return ApiProductConfiguratorBulkDeleteStepsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkDeleteStepsExecute(r ApiProductConfiguratorBulkDeleteStepsRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkDeleteSteps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/delete/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorBulkUpdateOptionsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratoroptionBulkUpdateRequest
}

func (r ApiProductConfiguratorBulkUpdateOptionsRequest) Body(body ProductconfiguratoroptionBulkUpdateRequest) ApiProductConfiguratorBulkUpdateOptionsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkUpdateOptionsRequest) Execute() (*ProductconfiguratoroptionBulkUpdateResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkUpdateOptionsExecute(r)
}

/*
ProductConfiguratorBulkUpdateOptions Method for ProductConfiguratorBulkUpdateOptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorBulkUpdateOptionsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkUpdateOptions(ctx context.Context, tenantId string) ApiProductConfiguratorBulkUpdateOptionsRequest {
	return ApiProductConfiguratorBulkUpdateOptionsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProductconfiguratoroptionBulkUpdateResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkUpdateOptionsExecute(r ApiProductConfiguratorBulkUpdateOptionsRequest) (*ProductconfiguratoroptionBulkUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratoroptionBulkUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkUpdateOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/option/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorBulkUpdatePropertiesRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratorpropertyBulkUpdateRequest
}

func (r ApiProductConfiguratorBulkUpdatePropertiesRequest) Body(body ProductconfiguratorpropertyBulkUpdateRequest) ApiProductConfiguratorBulkUpdatePropertiesRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorBulkUpdatePropertiesRequest) Execute() (*ProductconfiguratorpropertyBulkUpdateResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorBulkUpdatePropertiesExecute(r)
}

/*
ProductConfiguratorBulkUpdateProperties Method for ProductConfiguratorBulkUpdateProperties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorBulkUpdatePropertiesRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkUpdateProperties(ctx context.Context, tenantId string) ApiProductConfiguratorBulkUpdatePropertiesRequest {
	return ApiProductConfiguratorBulkUpdatePropertiesRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorpropertyBulkUpdateResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorBulkUpdatePropertiesExecute(r ApiProductConfiguratorBulkUpdatePropertiesRequest) (*ProductconfiguratorpropertyBulkUpdateResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorpropertyBulkUpdateResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorBulkUpdateProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/properties/bulk"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCopyConfiguratorRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	sourceConfiguratorId string
	body *ProductconfiguratorconfiguratorCopyRequest
}

func (r ApiProductConfiguratorCopyConfiguratorRequest) Body(body ProductconfiguratorconfiguratorCopyRequest) ApiProductConfiguratorCopyConfiguratorRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCopyConfiguratorRequest) Execute() (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCopyConfiguratorExecute(r)
}

/*
ProductConfiguratorCopyConfigurator Method for ProductConfiguratorCopyConfigurator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param sourceConfiguratorId
 @return ApiProductConfiguratorCopyConfiguratorRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCopyConfigurator(ctx context.Context, tenantId string, sourceConfiguratorId string) ApiProductConfiguratorCopyConfiguratorRequest {
	return ApiProductConfiguratorCopyConfiguratorRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		sourceConfiguratorId: sourceConfiguratorId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorconfiguratorEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCopyConfiguratorExecute(r ApiProductConfiguratorCopyConfiguratorRequest) (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorconfiguratorEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCopyConfigurator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{sourceConfiguratorId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceConfiguratorId"+"}", url.PathEscape(parameterToString(r.sourceConfiguratorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCopyOptionRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	sourceOptionId string
	body *ProductconfiguratoroptionCopyRequest
}

func (r ApiProductConfiguratorCopyOptionRequest) Body(body ProductconfiguratoroptionCopyRequest) ApiProductConfiguratorCopyOptionRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCopyOptionRequest) Execute() (*ProductconfiguratoroptionEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCopyOptionExecute(r)
}

/*
ProductConfiguratorCopyOption Method for ProductConfiguratorCopyOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param sourceOptionId
 @return ApiProductConfiguratorCopyOptionRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCopyOption(ctx context.Context, tenantId string, sourceOptionId string) ApiProductConfiguratorCopyOptionRequest {
	return ApiProductConfiguratorCopyOptionRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		sourceOptionId: sourceOptionId,
	}
}

// Execute executes the request
//  @return ProductconfiguratoroptionEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCopyOptionExecute(r ApiProductConfiguratorCopyOptionRequest) (*ProductconfiguratoroptionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratoroptionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCopyOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/option/{sourceOptionId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceOptionId"+"}", url.PathEscape(parameterToString(r.sourceOptionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCopyStepRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	sourceStepId string
	body *ProductconfiguratorstepCopyRequest
}

func (r ApiProductConfiguratorCopyStepRequest) Body(body ProductconfiguratorstepCopyRequest) ApiProductConfiguratorCopyStepRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCopyStepRequest) Execute() (*ProductconfiguratorstepEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCopyStepExecute(r)
}

/*
ProductConfiguratorCopyStep Method for ProductConfiguratorCopyStep

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param sourceStepId
 @return ApiProductConfiguratorCopyStepRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCopyStep(ctx context.Context, tenantId string, sourceStepId string) ApiProductConfiguratorCopyStepRequest {
	return ApiProductConfiguratorCopyStepRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		sourceStepId: sourceStepId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorstepEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCopyStepExecute(r ApiProductConfiguratorCopyStepRequest) (*ProductconfiguratorstepEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorstepEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCopyStep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{sourceStepId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sourceStepId"+"}", url.PathEscape(parameterToString(r.sourceStepId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCreateConfiguratorRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	body *ProductconfiguratorconfiguratorCreateRequest
}

func (r ApiProductConfiguratorCreateConfiguratorRequest) Body(body ProductconfiguratorconfiguratorCreateRequest) ApiProductConfiguratorCreateConfiguratorRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCreateConfiguratorRequest) Execute() (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCreateConfiguratorExecute(r)
}

/*
ProductConfiguratorCreateConfigurator Method for ProductConfiguratorCreateConfigurator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @return ApiProductConfiguratorCreateConfiguratorRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateConfigurator(ctx context.Context, tenantId string, productId string) ApiProductConfiguratorCreateConfiguratorRequest {
	return ApiProductConfiguratorCreateConfiguratorRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorconfiguratorEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateConfiguratorExecute(r ApiProductConfiguratorCreateConfiguratorRequest) (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorconfiguratorEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCreateConfigurator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCreateDependencyRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	stepId string
	body *ProductconfiguratordependencyCreateRequest
}

func (r ApiProductConfiguratorCreateDependencyRequest) Body(body ProductconfiguratordependencyCreateRequest) ApiProductConfiguratorCreateDependencyRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCreateDependencyRequest) Execute() (*ProductconfiguratordependencyEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCreateDependencyExecute(r)
}

/*
ProductConfiguratorCreateDependency Method for ProductConfiguratorCreateDependency

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param stepId
 @return ApiProductConfiguratorCreateDependencyRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateDependency(ctx context.Context, tenantId string, stepId string) ApiProductConfiguratorCreateDependencyRequest {
	return ApiProductConfiguratorCreateDependencyRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		stepId: stepId,
	}
}

// Execute executes the request
//  @return ProductconfiguratordependencyEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateDependencyExecute(r ApiProductConfiguratorCreateDependencyRequest) (*ProductconfiguratordependencyEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratordependencyEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCreateDependency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{stepId}/dependency/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepId"+"}", url.PathEscape(parameterToString(r.stepId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCreateMatrixRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratormatrixCreateRequest
}

func (r ApiProductConfiguratorCreateMatrixRequest) Body(body ProductconfiguratormatrixCreateRequest) ApiProductConfiguratorCreateMatrixRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCreateMatrixRequest) Execute() (*ProductconfiguratormatrixEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCreateMatrixExecute(r)
}

/*
ProductConfiguratorCreateMatrix Method for ProductConfiguratorCreateMatrix

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorCreateMatrixRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateMatrix(ctx context.Context, tenantId string) ApiProductConfiguratorCreateMatrixRequest {
	return ApiProductConfiguratorCreateMatrixRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProductconfiguratormatrixEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateMatrixExecute(r ApiProductConfiguratorCreateMatrixRequest) (*ProductconfiguratormatrixEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratormatrixEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCreateMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/matrix/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCreateOptionRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	stepId string
	body *ProductconfiguratoroptionCreateRequest
}

func (r ApiProductConfiguratorCreateOptionRequest) Body(body ProductconfiguratoroptionCreateRequest) ApiProductConfiguratorCreateOptionRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCreateOptionRequest) Execute() (*ProductconfiguratoroptionEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCreateOptionExecute(r)
}

/*
ProductConfiguratorCreateOption Method for ProductConfiguratorCreateOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param stepId
 @return ApiProductConfiguratorCreateOptionRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateOption(ctx context.Context, tenantId string, stepId string) ApiProductConfiguratorCreateOptionRequest {
	return ApiProductConfiguratorCreateOptionRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		stepId: stepId,
	}
}

// Execute executes the request
//  @return ProductconfiguratoroptionEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateOptionExecute(r ApiProductConfiguratorCreateOptionRequest) (*ProductconfiguratoroptionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratoroptionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCreateOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{stepId}/option/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepId"+"}", url.PathEscape(parameterToString(r.stepId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCreatePropertyRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	body *ProductconfiguratorpropertyCreateRequest
}

func (r ApiProductConfiguratorCreatePropertyRequest) Body(body ProductconfiguratorpropertyCreateRequest) ApiProductConfiguratorCreatePropertyRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCreatePropertyRequest) Execute() (*ProductconfiguratorpropertyEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCreatePropertyExecute(r)
}

/*
ProductConfiguratorCreateProperty Method for ProductConfiguratorCreateProperty

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @return ApiProductConfiguratorCreatePropertyRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateProperty(ctx context.Context, tenantId string) ApiProductConfiguratorCreatePropertyRequest {
	return ApiProductConfiguratorCreatePropertyRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorpropertyEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCreatePropertyExecute(r ApiProductConfiguratorCreatePropertyRequest) (*ProductconfiguratorpropertyEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorpropertyEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCreateProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/property/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorCreateStepRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	configuratorId string
	body *ProductconfiguratorstepCreateRequest
}

func (r ApiProductConfiguratorCreateStepRequest) Body(body ProductconfiguratorstepCreateRequest) ApiProductConfiguratorCreateStepRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorCreateStepRequest) Execute() (*ProductconfiguratorstepEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorCreateStepExecute(r)
}

/*
ProductConfiguratorCreateStep Method for ProductConfiguratorCreateStep

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param configuratorId
 @return ApiProductConfiguratorCreateStepRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateStep(ctx context.Context, tenantId string, configuratorId string) ApiProductConfiguratorCreateStepRequest {
	return ApiProductConfiguratorCreateStepRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		configuratorId: configuratorId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorstepEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorCreateStepExecute(r ApiProductConfiguratorCreateStepRequest) (*ProductconfiguratorstepEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorstepEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorCreateStep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/configurator/{configuratorId}/step/create"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuratorId"+"}", url.PathEscape(parameterToString(r.configuratorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorDeleteConfiguratorRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	configuratorId string
}

func (r ApiProductConfiguratorDeleteConfiguratorRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorDeleteConfiguratorExecute(r)
}

/*
ProductConfiguratorDeleteConfigurator Method for ProductConfiguratorDeleteConfigurator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param configuratorId
 @return ApiProductConfiguratorDeleteConfiguratorRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteConfigurator(ctx context.Context, tenantId string, configuratorId string) ApiProductConfiguratorDeleteConfiguratorRequest {
	return ApiProductConfiguratorDeleteConfiguratorRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		configuratorId: configuratorId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteConfiguratorExecute(r ApiProductConfiguratorDeleteConfiguratorRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorDeleteConfigurator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/configurator/{configuratorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuratorId"+"}", url.PathEscape(parameterToString(r.configuratorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorDeleteDependencyRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	dependencyId string
}

func (r ApiProductConfiguratorDeleteDependencyRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorDeleteDependencyExecute(r)
}

/*
ProductConfiguratorDeleteDependency Method for ProductConfiguratorDeleteDependency

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param dependencyId
 @return ApiProductConfiguratorDeleteDependencyRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteDependency(ctx context.Context, tenantId string, dependencyId string) ApiProductConfiguratorDeleteDependencyRequest {
	return ApiProductConfiguratorDeleteDependencyRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		dependencyId: dependencyId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteDependencyExecute(r ApiProductConfiguratorDeleteDependencyRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorDeleteDependency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/dependency/{dependencyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dependencyId"+"}", url.PathEscape(parameterToString(r.dependencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorDeleteMatrixRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	matrixId string
}

func (r ApiProductConfiguratorDeleteMatrixRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorDeleteMatrixExecute(r)
}

/*
ProductConfiguratorDeleteMatrix Method for ProductConfiguratorDeleteMatrix

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param matrixId
 @return ApiProductConfiguratorDeleteMatrixRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteMatrix(ctx context.Context, tenantId string, matrixId string) ApiProductConfiguratorDeleteMatrixRequest {
	return ApiProductConfiguratorDeleteMatrixRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		matrixId: matrixId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteMatrixExecute(r ApiProductConfiguratorDeleteMatrixRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorDeleteMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/matrix/{matrixId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"matrixId"+"}", url.PathEscape(parameterToString(r.matrixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorDeleteOptionRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	optionId string
}

func (r ApiProductConfiguratorDeleteOptionRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorDeleteOptionExecute(r)
}

/*
ProductConfiguratorDeleteOption Method for ProductConfiguratorDeleteOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param optionId
 @return ApiProductConfiguratorDeleteOptionRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteOption(ctx context.Context, tenantId string, optionId string) ApiProductConfiguratorDeleteOptionRequest {
	return ApiProductConfiguratorDeleteOptionRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		optionId: optionId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteOptionExecute(r ApiProductConfiguratorDeleteOptionRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorDeleteOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/option/{optionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"optionId"+"}", url.PathEscape(parameterToString(r.optionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorDeleteStepRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	stepId string
}

func (r ApiProductConfiguratorDeleteStepRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ProductConfiguratorDeleteStepExecute(r)
}

/*
ProductConfiguratorDeleteStep Method for ProductConfiguratorDeleteStep

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param stepId
 @return ApiProductConfiguratorDeleteStepRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteStep(ctx context.Context, tenantId string, stepId string) ApiProductConfiguratorDeleteStepRequest {
	return ApiProductConfiguratorDeleteStepRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		stepId: stepId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *ProductConfiguratorApiService) ProductConfiguratorDeleteStepExecute(r ApiProductConfiguratorDeleteStepRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorDeleteStep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{stepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepId"+"}", url.PathEscape(parameterToString(r.stepId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorGetAvailableConfigurationRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	configuratorId *string
}

func (r ApiProductConfiguratorGetAvailableConfigurationRequest) ConfiguratorId(configuratorId string) ApiProductConfiguratorGetAvailableConfigurationRequest {
	r.configuratorId = &configuratorId
	return r
}

func (r ApiProductConfiguratorGetAvailableConfigurationRequest) Execute() (*ConfigurationGetAvailableConfigurationResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorGetAvailableConfigurationExecute(r)
}

/*
ProductConfiguratorGetAvailableConfiguration Method for ProductConfiguratorGetAvailableConfiguration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @return ApiProductConfiguratorGetAvailableConfigurationRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorGetAvailableConfiguration(ctx context.Context, tenantId string, productId string) ApiProductConfiguratorGetAvailableConfigurationRequest {
	return ApiProductConfiguratorGetAvailableConfigurationRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ConfigurationGetAvailableConfigurationResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorGetAvailableConfigurationExecute(r ApiProductConfiguratorGetAvailableConfigurationRequest) (*ConfigurationGetAvailableConfigurationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigurationGetAvailableConfigurationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorGetAvailableConfiguration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.configuratorId != nil {
		localVarQueryParams.Add("configuratorId", parameterToString(*r.configuratorId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorGetAvailableConfiguration2Request struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	body *ConfigurationGetAvailableConfigurationRequest
}

func (r ApiProductConfiguratorGetAvailableConfiguration2Request) Body(body ConfigurationGetAvailableConfigurationRequest) ApiProductConfiguratorGetAvailableConfiguration2Request {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorGetAvailableConfiguration2Request) Execute() (*ConfigurationGetAvailableConfigurationResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorGetAvailableConfiguration2Execute(r)
}

/*
ProductConfiguratorGetAvailableConfiguration2 Method for ProductConfiguratorGetAvailableConfiguration2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @return ApiProductConfiguratorGetAvailableConfiguration2Request
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorGetAvailableConfiguration2(ctx context.Context, tenantId string, productId string) ApiProductConfiguratorGetAvailableConfiguration2Request {
	return ApiProductConfiguratorGetAvailableConfiguration2Request{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ConfigurationGetAvailableConfigurationResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorGetAvailableConfiguration2Execute(r ApiProductConfiguratorGetAvailableConfiguration2Request) (*ConfigurationGetAvailableConfigurationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigurationGetAvailableConfigurationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorGetAvailableConfiguration2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}/configuration"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorGetConfigurationFromSelectionsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	body *ConfigurationGetConfigurationFromSelectionsRequest
}

func (r ApiProductConfiguratorGetConfigurationFromSelectionsRequest) Body(body ConfigurationGetConfigurationFromSelectionsRequest) ApiProductConfiguratorGetConfigurationFromSelectionsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorGetConfigurationFromSelectionsRequest) Execute() (*ConfigurationGetConfigurationFromSelectionsResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorGetConfigurationFromSelectionsExecute(r)
}

/*
ProductConfiguratorGetConfigurationFromSelections Method for ProductConfiguratorGetConfigurationFromSelections

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @return ApiProductConfiguratorGetConfigurationFromSelectionsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorGetConfigurationFromSelections(ctx context.Context, tenantId string, productId string) ApiProductConfiguratorGetConfigurationFromSelectionsRequest {
	return ApiProductConfiguratorGetConfigurationFromSelectionsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ConfigurationGetConfigurationFromSelectionsResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorGetConfigurationFromSelectionsExecute(r ApiProductConfiguratorGetConfigurationFromSelectionsRequest) (*ConfigurationGetConfigurationFromSelectionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfigurationGetConfigurationFromSelectionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorGetConfigurationFromSelections")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}/configuration-from-selections"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorGetConfiguratorByProductIdRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	status *string
}

func (r ApiProductConfiguratorGetConfiguratorByProductIdRequest) Status(status string) ApiProductConfiguratorGetConfiguratorByProductIdRequest {
	r.status = &status
	return r
}

func (r ApiProductConfiguratorGetConfiguratorByProductIdRequest) Execute() (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorGetConfiguratorByProductIdExecute(r)
}

/*
ProductConfiguratorGetConfiguratorByProductId Method for ProductConfiguratorGetConfiguratorByProductId

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @return ApiProductConfiguratorGetConfiguratorByProductIdRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorGetConfiguratorByProductId(ctx context.Context, tenantId string, productId string) ApiProductConfiguratorGetConfiguratorByProductIdRequest {
	return ApiProductConfiguratorGetConfiguratorByProductIdRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorconfiguratorEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorGetConfiguratorByProductIdExecute(r ApiProductConfiguratorGetConfiguratorByProductIdRequest) (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorconfiguratorEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorGetConfiguratorByProductId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorGetConfiguratorByProductId2Request struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	status string
}

func (r ApiProductConfiguratorGetConfiguratorByProductId2Request) Execute() (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorGetConfiguratorByProductId2Execute(r)
}

/*
ProductConfiguratorGetConfiguratorByProductId2 Method for ProductConfiguratorGetConfiguratorByProductId2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @param status
 @return ApiProductConfiguratorGetConfiguratorByProductId2Request
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorGetConfiguratorByProductId2(ctx context.Context, tenantId string, productId string, status string) ApiProductConfiguratorGetConfiguratorByProductId2Request {
	return ApiProductConfiguratorGetConfiguratorByProductId2Request{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
		status: status,
	}
}

// Execute executes the request
//  @return ProductconfiguratorconfiguratorEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorGetConfiguratorByProductId2Execute(r ApiProductConfiguratorGetConfiguratorByProductId2Request) (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorconfiguratorEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorGetConfiguratorByProductId2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}/status/{status}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"status"+"}", url.PathEscape(parameterToString(r.status, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorGetMatrixRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	matrixId string
}

func (r ApiProductConfiguratorGetMatrixRequest) Execute() (*ProductconfiguratormatrixEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorGetMatrixExecute(r)
}

/*
ProductConfiguratorGetMatrix Method for ProductConfiguratorGetMatrix

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param matrixId
 @return ApiProductConfiguratorGetMatrixRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorGetMatrix(ctx context.Context, tenantId string, matrixId string) ApiProductConfiguratorGetMatrixRequest {
	return ApiProductConfiguratorGetMatrixRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		matrixId: matrixId,
	}
}

// Execute executes the request
//  @return ProductconfiguratormatrixEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorGetMatrixExecute(r ApiProductConfiguratorGetMatrixRequest) (*ProductconfiguratormatrixEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratormatrixEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorGetMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/matrix/{matrixId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"matrixId"+"}", url.PathEscape(parameterToString(r.matrixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorListConfiguratorsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	productId string
	pageSize int64
	body *ConfiguratorListRequest
}

func (r ApiProductConfiguratorListConfiguratorsRequest) Body(body ConfiguratorListRequest) ApiProductConfiguratorListConfiguratorsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorListConfiguratorsRequest) Execute() (*ConfiguratorListResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorListConfiguratorsExecute(r)
}

/*
ProductConfiguratorListConfigurators Method for ProductConfiguratorListConfigurators

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param productId
 @param pageSize
 @return ApiProductConfiguratorListConfiguratorsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorListConfigurators(ctx context.Context, tenantId string, productId string, pageSize int64) ApiProductConfiguratorListConfiguratorsRequest {
	return ApiProductConfiguratorListConfiguratorsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		productId: productId,
		pageSize: pageSize,
	}
}

// Execute executes the request
//  @return ConfiguratorListResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorListConfiguratorsExecute(r ApiProductConfiguratorListConfiguratorsRequest) (*ConfiguratorListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConfiguratorListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorListConfigurators")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/product/{productId}/page-size/{pageSize}/configurators"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"productId"+"}", url.PathEscape(parameterToString(r.productId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", url.PathEscape(parameterToString(r.pageSize, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorListDependenciesRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	pageSize int64
	body *DependencyListDependenciesRequest
}

func (r ApiProductConfiguratorListDependenciesRequest) Body(body DependencyListDependenciesRequest) ApiProductConfiguratorListDependenciesRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorListDependenciesRequest) Execute() (*DependencyListDependenciesResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorListDependenciesExecute(r)
}

/*
ProductConfiguratorListDependencies Method for ProductConfiguratorListDependencies

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param pageSize
 @return ApiProductConfiguratorListDependenciesRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorListDependencies(ctx context.Context, tenantId string, pageSize int64) ApiProductConfiguratorListDependenciesRequest {
	return ApiProductConfiguratorListDependenciesRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		pageSize: pageSize,
	}
}

// Execute executes the request
//  @return DependencyListDependenciesResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorListDependenciesExecute(r ApiProductConfiguratorListDependenciesRequest) (*DependencyListDependenciesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DependencyListDependenciesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorListDependencies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/page-size/{pageSize}/dependencies"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", url.PathEscape(parameterToString(r.pageSize, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorListMatricesRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	configuratorId string
	pageSize string
	body *MatrixListMatricesRequest
}

func (r ApiProductConfiguratorListMatricesRequest) Body(body MatrixListMatricesRequest) ApiProductConfiguratorListMatricesRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorListMatricesRequest) Execute() (*MatrixListMatricesResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorListMatricesExecute(r)
}

/*
ProductConfiguratorListMatrices Method for ProductConfiguratorListMatrices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param configuratorId
 @param pageSize
 @return ApiProductConfiguratorListMatricesRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorListMatrices(ctx context.Context, tenantId string, configuratorId string, pageSize string) ApiProductConfiguratorListMatricesRequest {
	return ApiProductConfiguratorListMatricesRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		configuratorId: configuratorId,
		pageSize: pageSize,
	}
}

// Execute executes the request
//  @return MatrixListMatricesResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorListMatricesExecute(r ApiProductConfiguratorListMatricesRequest) (*MatrixListMatricesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MatrixListMatricesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorListMatrices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/configurator/{configuratorId}/page-size/{pageSize}/matrices"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuratorId"+"}", url.PathEscape(parameterToString(r.configuratorId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", url.PathEscape(parameterToString(r.pageSize, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorListOptionsRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	stepId string
	pageSize int64
	body *OptionListOptionsRequest
}

func (r ApiProductConfiguratorListOptionsRequest) Body(body OptionListOptionsRequest) ApiProductConfiguratorListOptionsRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorListOptionsRequest) Execute() (*OptionListOptionsResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorListOptionsExecute(r)
}

/*
ProductConfiguratorListOptions Method for ProductConfiguratorListOptions

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param stepId
 @param pageSize
 @return ApiProductConfiguratorListOptionsRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorListOptions(ctx context.Context, tenantId string, stepId string, pageSize int64) ApiProductConfiguratorListOptionsRequest {
	return ApiProductConfiguratorListOptionsRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		stepId: stepId,
		pageSize: pageSize,
	}
}

// Execute executes the request
//  @return OptionListOptionsResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorListOptionsExecute(r ApiProductConfiguratorListOptionsRequest) (*OptionListOptionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OptionListOptionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorListOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{stepId}/page-size/{pageSize}/options"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepId"+"}", url.PathEscape(parameterToString(r.stepId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", url.PathEscape(parameterToString(r.pageSize, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorListPropertiesRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	matrixId string
	pageSize string
	body *PropertyListPropertiesRequest
}

func (r ApiProductConfiguratorListPropertiesRequest) Body(body PropertyListPropertiesRequest) ApiProductConfiguratorListPropertiesRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorListPropertiesRequest) Execute() (*PropertyListPropertiesResponse, *http.Response, error) {
	return r.ApiService.ProductConfiguratorListPropertiesExecute(r)
}

/*
ProductConfiguratorListProperties Method for ProductConfiguratorListProperties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param matrixId
 @param pageSize
 @return ApiProductConfiguratorListPropertiesRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorListProperties(ctx context.Context, tenantId string, matrixId string, pageSize string) ApiProductConfiguratorListPropertiesRequest {
	return ApiProductConfiguratorListPropertiesRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		matrixId: matrixId,
		pageSize: pageSize,
	}
}

// Execute executes the request
//  @return PropertyListPropertiesResponse
func (a *ProductConfiguratorApiService) ProductConfiguratorListPropertiesExecute(r ApiProductConfiguratorListPropertiesRequest) (*PropertyListPropertiesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PropertyListPropertiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorListProperties")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/matrix/{matrixId}/page-size/{pageSize}/properties"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"matrixId"+"}", url.PathEscape(parameterToString(r.matrixId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pageSize"+"}", url.PathEscape(parameterToString(r.pageSize, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorRemovePricelistFromMatrixRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	matrixId string
	pricelistGrn string
}

func (r ApiProductConfiguratorRemovePricelistFromMatrixRequest) Execute() (*ProductconfiguratormatrixEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorRemovePricelistFromMatrixExecute(r)
}

/*
ProductConfiguratorRemovePricelistFromMatrix Method for ProductConfiguratorRemovePricelistFromMatrix

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param matrixId
 @param pricelistGrn
 @return ApiProductConfiguratorRemovePricelistFromMatrixRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorRemovePricelistFromMatrix(ctx context.Context, tenantId string, matrixId string, pricelistGrn string) ApiProductConfiguratorRemovePricelistFromMatrixRequest {
	return ApiProductConfiguratorRemovePricelistFromMatrixRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		matrixId: matrixId,
		pricelistGrn: pricelistGrn,
	}
}

// Execute executes the request
//  @return ProductconfiguratormatrixEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorRemovePricelistFromMatrixExecute(r ApiProductConfiguratorRemovePricelistFromMatrixRequest) (*ProductconfiguratormatrixEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratormatrixEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorRemovePricelistFromMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/matrix/{matrixId}/pricelist/{pricelistGrn}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"matrixId"+"}", url.PathEscape(parameterToString(r.matrixId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"pricelistGrn"+"}", url.PathEscape(parameterToString(r.pricelistGrn, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorUpdateConfiguratorRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	configuratorId string
	body *ProductconfiguratorconfiguratorUpdateRequest
}

func (r ApiProductConfiguratorUpdateConfiguratorRequest) Body(body ProductconfiguratorconfiguratorUpdateRequest) ApiProductConfiguratorUpdateConfiguratorRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorUpdateConfiguratorRequest) Execute() (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorUpdateConfiguratorExecute(r)
}

/*
ProductConfiguratorUpdateConfigurator Method for ProductConfiguratorUpdateConfigurator

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param configuratorId
 @return ApiProductConfiguratorUpdateConfiguratorRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateConfigurator(ctx context.Context, tenantId string, configuratorId string) ApiProductConfiguratorUpdateConfiguratorRequest {
	return ApiProductConfiguratorUpdateConfiguratorRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		configuratorId: configuratorId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorconfiguratorEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateConfiguratorExecute(r ApiProductConfiguratorUpdateConfiguratorRequest) (*ProductconfiguratorconfiguratorEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorconfiguratorEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorUpdateConfigurator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/configurator/{configuratorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"configuratorId"+"}", url.PathEscape(parameterToString(r.configuratorId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorUpdateDependencyRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	dependencyId string
	body *ProductconfiguratordependencyUpdateRequest
}

func (r ApiProductConfiguratorUpdateDependencyRequest) Body(body ProductconfiguratordependencyUpdateRequest) ApiProductConfiguratorUpdateDependencyRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorUpdateDependencyRequest) Execute() (*ProductconfiguratordependencyEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorUpdateDependencyExecute(r)
}

/*
ProductConfiguratorUpdateDependency Method for ProductConfiguratorUpdateDependency

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param dependencyId
 @return ApiProductConfiguratorUpdateDependencyRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateDependency(ctx context.Context, tenantId string, dependencyId string) ApiProductConfiguratorUpdateDependencyRequest {
	return ApiProductConfiguratorUpdateDependencyRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		dependencyId: dependencyId,
	}
}

// Execute executes the request
//  @return ProductconfiguratordependencyEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateDependencyExecute(r ApiProductConfiguratorUpdateDependencyRequest) (*ProductconfiguratordependencyEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratordependencyEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorUpdateDependency")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/dependency/{dependencyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"dependencyId"+"}", url.PathEscape(parameterToString(r.dependencyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorUpdateMatrixRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	matrixId string
	body *ProductconfiguratormatrixUpdateRequest
}

func (r ApiProductConfiguratorUpdateMatrixRequest) Body(body ProductconfiguratormatrixUpdateRequest) ApiProductConfiguratorUpdateMatrixRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorUpdateMatrixRequest) Execute() (*ProductconfiguratormatrixEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorUpdateMatrixExecute(r)
}

/*
ProductConfiguratorUpdateMatrix Method for ProductConfiguratorUpdateMatrix

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param matrixId
 @return ApiProductConfiguratorUpdateMatrixRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateMatrix(ctx context.Context, tenantId string, matrixId string) ApiProductConfiguratorUpdateMatrixRequest {
	return ApiProductConfiguratorUpdateMatrixRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		matrixId: matrixId,
	}
}

// Execute executes the request
//  @return ProductconfiguratormatrixEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateMatrixExecute(r ApiProductConfiguratorUpdateMatrixRequest) (*ProductconfiguratormatrixEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratormatrixEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorUpdateMatrix")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/matrix/{matrixId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"matrixId"+"}", url.PathEscape(parameterToString(r.matrixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorUpdateOptionRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	optionId string
	body *ProductconfiguratoroptionUpdateRequest
}

func (r ApiProductConfiguratorUpdateOptionRequest) Body(body ProductconfiguratoroptionUpdateRequest) ApiProductConfiguratorUpdateOptionRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorUpdateOptionRequest) Execute() (*ProductconfiguratoroptionEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorUpdateOptionExecute(r)
}

/*
ProductConfiguratorUpdateOption Method for ProductConfiguratorUpdateOption

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param optionId
 @return ApiProductConfiguratorUpdateOptionRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateOption(ctx context.Context, tenantId string, optionId string) ApiProductConfiguratorUpdateOptionRequest {
	return ApiProductConfiguratorUpdateOptionRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		optionId: optionId,
	}
}

// Execute executes the request
//  @return ProductconfiguratoroptionEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateOptionExecute(r ApiProductConfiguratorUpdateOptionRequest) (*ProductconfiguratoroptionEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratoroptionEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorUpdateOption")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/option/{optionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"optionId"+"}", url.PathEscape(parameterToString(r.optionId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorUpdatePropertyRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	propertyId string
	body *ProductconfiguratorpropertyUpdateRequest
}

func (r ApiProductConfiguratorUpdatePropertyRequest) Body(body ProductconfiguratorpropertyUpdateRequest) ApiProductConfiguratorUpdatePropertyRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorUpdatePropertyRequest) Execute() (*ProductconfiguratorpropertyEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorUpdatePropertyExecute(r)
}

/*
ProductConfiguratorUpdateProperty Method for ProductConfiguratorUpdateProperty

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param propertyId
 @return ApiProductConfiguratorUpdatePropertyRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateProperty(ctx context.Context, tenantId string, propertyId string) ApiProductConfiguratorUpdatePropertyRequest {
	return ApiProductConfiguratorUpdatePropertyRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		propertyId: propertyId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorpropertyEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdatePropertyExecute(r ApiProductConfiguratorUpdatePropertyRequest) (*ProductconfiguratorpropertyEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorpropertyEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorUpdateProperty")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/property/{propertyId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"propertyId"+"}", url.PathEscape(parameterToString(r.propertyId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductConfiguratorUpdateStepRequest struct {
	ctx context.Context
	ApiService *ProductConfiguratorApiService
	tenantId string
	stepId string
	body *ProductconfiguratorstepUpdateRequest
}

func (r ApiProductConfiguratorUpdateStepRequest) Body(body ProductconfiguratorstepUpdateRequest) ApiProductConfiguratorUpdateStepRequest {
	r.body = &body
	return r
}

func (r ApiProductConfiguratorUpdateStepRequest) Execute() (*ProductconfiguratorstepEntity, *http.Response, error) {
	return r.ApiService.ProductConfiguratorUpdateStepExecute(r)
}

/*
ProductConfiguratorUpdateStep Method for ProductConfiguratorUpdateStep

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tenantId
 @param stepId
 @return ApiProductConfiguratorUpdateStepRequest
*/
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateStep(ctx context.Context, tenantId string, stepId string) ApiProductConfiguratorUpdateStepRequest {
	return ApiProductConfiguratorUpdateStepRequest{
		ApiService: a,
		ctx: ctx,
		tenantId: tenantId,
		stepId: stepId,
	}
}

// Execute executes the request
//  @return ProductconfiguratorstepEntity
func (a *ProductConfiguratorApiService) ProductConfiguratorUpdateStepExecute(r ApiProductConfiguratorUpdateStepRequest) (*ProductconfiguratorstepEntity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProductconfiguratorstepEntity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductConfiguratorApiService.ProductConfiguratorUpdateStep")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v1/{tenantId}/step/{stepId}"
	localVarPath = strings.Replace(localVarPath, "{"+"tenantId"+"}", url.PathEscape(parameterToString(r.tenantId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"stepId"+"}", url.PathEscape(parameterToString(r.stepId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v GooglerpcStatus
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
            		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
            		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
